import{DB_NAMES_BLOOM,DB_NAMES_RAW,REGEX_DBS,DB_DIR,DB_NAME_FEATURE_FLAGS,DB_NAMES_JSON,DB_NAME_MV3_DYNAMIC_WHITELIST_JSON,DB_HEURISTICS}from"./db-consts";import{IndexedDatabase}from"./indexed-database";import{IndexedDatabaseFile}from"./indexed-database-file";import{isIndexedDbAvailable,cleanDbName,objToBinary}from"../utils";import{simpleStorageGet,simpleStorageSet}from"../storage.ts";import{getObjs as getObjsIndexedDb,saveObjs as saveObjsIndexedDb}from"../indexed-db.ts";import{fileWrite,fileDelete,queuedFileRead}from"../file";import bundledDbVersions from"../../db/version.json";export const parseDbsParameter=e=>{const a=new Set(e),o=DB_NAMES_BLOOM.filter((e=>a.has(e))),s=DB_NAMES_RAW.filter((e=>a.has(e))),n=DB_NAMES_JSON.filter((e=>a.has(e))),t=o.map((e=>({name:e,cleanName:cleanDbName(e),isBloom:!0,isFeatureFlags:!1}))).concat(s.map((e=>({name:e,cleanName:cleanDbName(e),isBloom:!1,isFeatureFlags:!1})))).concat(n.map((e=>({name:e,cleanName:cleanDbName(e),isBloom:!1,isFeatureFlags:!1,isJson:!0}))));return a.has(DB_NAME_FEATURE_FLAGS)&&t.push({name:DB_NAME_FEATURE_FLAGS,cleanName:cleanDbName(DB_NAME_FEATURE_FLAGS),isBloom:!1,isFeatureFlags:!0}),a.has(DB_NAME_MV3_DYNAMIC_WHITELIST_JSON)&&t.push({name:DB_NAME_MV3_DYNAMIC_WHITELIST_JSON,cleanName:cleanDbName(DB_NAME_MV3_DYNAMIC_WHITELIST_JSON),isBloom:!1,isFeatureFlags:!1}),t};export const loadBundledDatabases=async e=>{console.debug("LBD: Forcing reading bundled databases at "+(new Date).toLocaleString()),console.debug("LBD: Databases to be loaded:",e);const a=parseDbsParameter(e);let o=[];for(let e=0;e<a.length;e++)try{let s=await loadBundledDb(a[e].name,a[e].isBloom,a[e].isFeatureFlags);o.push(s)}catch(o){console.debug(`LBD: Error loading ${a[e].name} from the bundle`,o)}const s=[];return o.forEach((e=>{if(!bundledDbVersions[e.name])return void console.warn(`LBD: No DB found for ${e.name}`);let a=bundledDbVersions[e.name].version||"0";s.push(buildDbResult(e,a))})),console.debug("LBD: Bundled unpack complete at "+(new Date).toLocaleString()),console.log(`LBD: ${s.length} bundled databases loaded`),s};export const loadCachedDatabases=async e=>{if(!isIndexedDbAvailable())return console.warn("LCD: IndexedDB not available in this browser"),[];const a=parseDbsParameter(e),o=await getObjsIndexedDb({dbName:"cachedDb",storeName:"cachedDbStore",storeOptions:{keyPath:"dbName"},waitStrategy:"allSettled",keys:a.map((e=>e.cleanName))}),s=[];o.forEach(((e,o)=>{if(!e)return void console.warn(`LCD: No cache db for ${a[o].name}`);const n=a[o];if("rejected"===e.status)return void console.warn(`LCD: Error loading ${n.name} from the cache`,e.reason);if("fulfilled"!==e.status)return void console.log(`LCD: ${n.name} not loaded from cache`);const t=e.value;t?t.dbName&&t.data?s.push(buildDbResult({name:n.name,isBloom:n.isBloom,isFeatureFlags:n.isFeatureFlags,isRaw:!n.isBloom,result:n.isBloom?new IndexedDatabase(n.name,t.data.bloomFilter):t.data},t.version)):console.debug(`LCD: No cache db for ${n.name}.`,n.name):console.log(`LCD: ${n.name} not loaded from cache`)}));const n=s.filter((e=>!e.version));if(n.length>0){console.warn(`LCD: Found ${n.length} dbs with no version in the cache, querying simpleStorage to get the version`),console.debug("LCD: Cache databases with no version",n.map((e=>e.name)));const e=await simpleStorageGet("databases")||{};n.forEach((a=>{a.version=e[a.name]&&e[a.name].version,console.debug(`LCD: Version for ${a.name}:`,a.version)}));const a=n.filter((e=>e.version));a.length>0&&(console.debug(`LCD: Re-writing ${a.length} databases in the cache, version was set`),await saveDbsToCache(a))}return console.log(`LCD: ${s.length} databases loaded from the cache`),s};export const saveDbsToCache=async e=>{if(!isIndexedDbAvailable())return console.warn("SDTC: IndexedDB not available in this browser"),!1;var a=e.map((e=>{let a;return a=e.rawData?e.rawData:e.data instanceof Set?Array.from(e.data):e.data,{dbName:e.cleanName,data:a,version:e.version}}));return await saveObjsIndexedDb({dbName:"cachedDb",storeName:"cachedDbStore",storeOptions:{keyPath:"dbName"},values:a}),!0};export const loadIdbStorageDatabases=async e=>{if(!isIndexedDbAvailable())return console.warn("LISD: IndexedDB not available in this browser"),[];const a=parseDbsParameter(e),o=[];a.forEach((e=>{o.push(loadIdbStorageDb(e.name,e.isBloom,e.isFeatureFlags))}));const s=[];(await Promise.allSettled(o)).forEach(((e,o)=>{const n=a[o];if("rejected"==e.status)return void console.warn(`LISD: Error loading ${n.name} from the IdbStorage`,e.reason);const t=e.value;s.push(buildDbResult(t,t.version))}));const n=s.filter((e=>!e.version));if(n.length>0){console.warn(`LISD: Found ${n.length} dbs with no version file, querying simpleStorage to get the version`),console.debug("LISD: Databases with no version",n.map((e=>e.name)));const e=await simpleStorageGet("databases")||{},a=[];if(n.forEach((o=>{o.version=e[o.name]&&e[o.name].version,console.debug(`LISD: Version for ${o.name}:`,o.version),o.version&&a.push(saveVersionFile(o.name,o.version))})),a.length>0)try{await Promise.all(a),console.debug(`LISD: ${a.length} version files created`)}catch(e){console.error("LISD: Error saving version files",e)}}return console.log(`LBD: ${s.length} databases loaded from IdbStorage`),s};export const saveDownloadedDb=(e,a,o)=>{if(!a)throw new Error("Version is required");return Promise.all([fileDelete(DB_DIR,e),fileWrite(DB_DIR,e,o),saveVersionFile(e,a),simpleStorageSet({idbStorageDatabases:!0})])};const saveVersionFile=(e,a)=>{const o=objToBinary({name:e,version:a});return fileWrite(DB_DIR,`${e}.version`,o)},getVersionFromVersionFile=(e,a)=>{if(a)try{return JSON.parse((new TextDecoder).decode(a)).version}catch(a){return void console.warn(`GVFVF: Error parsing version file for ${e}`,a)}else console.warn(`GVFVF: Version file for ${e} is falsy`,a)};export const buildDbResult=(e,a)=>{const o={};if(o.name=e.name,o.version=a,o.cleanName=cleanDbName(o.name),o.isBloom=e.isBloom,o.isRaw=e.isRaw,o.data=e.result,o.isFeatureFlags=e.isFeatureFlags,"malware_urls"==o.cleanName&&(o.rawData=o.data,o.data=new Set(o.data)),REGEX_DBS.includes(o.cleanName)&&(o.rawData=o.data,o.data=o.data.map((e=>new RegExp(e,"i"))),o.isRegex=!0),DB_NAMES_JSON.filter((e=>e!==DB_HEURISTICS)).includes(o.name)){o.isJson=!0,o.rawData=o.data;for(let e=0;e<o.data.length;e++){let a=o.data[e]?.r;if(!a&&"string"==typeof o.data[e]){let a=o.data[e],s={s:!1,r:new RegExp(a)};o.data[e]=s}if(a&&"string"==typeof a){let s=a;s.startsWith("/")&&s.endsWith("/")&&(s=s.slice(1,-1),s=s.replace(/\\\\/g,"\\"));try{o.data[e].r=new RegExp(s)}catch(a){console.debug(`Error parsing regex ${s} from ${o.name}`,a),delete o.data[e]}}}o.data=o.data.filter((e=>e))}return o};export const loadBundledDb=(e,a,o)=>{const s=a&&new IndexedDatabase(e),n=!a&&new IndexedDatabaseFile(e);return(a?s.parseBundled():n.readBundled()).then((n=>({name:e,isBloom:a,isFeatureFlags:o,isRaw:!a,result:a?s:n})))};export const loadIdbStorageDb=(e,a,o)=>{const s=a&&new IndexedDatabase(e),n=!a&&new IndexedDatabaseFile(e),t=a?s.parse():n.read();return Promise.allSettled([t,queuedFileRead(`${e}.version`)]).then((n=>{const[t,r]=n;if("rejected"==t.status){if("string"==typeof t.reason)throw new Error(`Error loading ${e} from IdbStorage: ${t.reason}`);throw t.reason}const i=getVersionFromVersionFile(e,r.value);return{name:e,isBloom:a,isFeatureFlags:o,isRaw:!a,result:a?s:t.value,version:i}}))};